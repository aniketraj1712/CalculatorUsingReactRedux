{"ast":null,"code":"export const calculation = (calcArray, currentResult) => {\n  // Get the current calc array \n  // Convert calc array to string\n  // Split string based on operators (/ * - +)\n  // Loop over array and make calculation\n  if (isNaN(calcArray[calcArray.length - 1])) {\n    return currentResult;\n  } // Operator functions that are invoked\n  // on the loop to calculate the values\n  // in calculation array\n\n\n  const operatorFunctions = {\n    '+': (a, b) => {\n      return a + b;\n    },\n    '-': (a, b) => {\n      return a - b;\n    },\n    '*': (a, b) => {\n      return a * b;\n    },\n    '/': (a, b) => {\n      return a / b;\n    }\n  }; // Join the calc array to create a string\n  // I do thos to make it easier to join the numbers\n  // so that the calculation loop can be done\n\n  let calcString = calcArray.join(''); // Split the calc string based on the operators\n  // This will allow me to combine the numbers and seperate\n  // the operators\n  // Example [4,5,'+',2,'/',6] -> '45+2/6' -> ['45','+','2','/','6']\n\n  let calcArrayUpdated = calcString.split(/(\\+|-|\\*|\\/)/g); // Set default result to 0\n\n  let result = 0; // Set a default operator value\n  // I do this as having non assigned vars\n  // is bad practice in most companies I have worked for\n\n  let operator = '+'; // Loop and calculate\n  // I do this to ensure that the correct order of operations is achieved\n  // If I did standard math on the values it would follow the\n  // order of operations as if it was a whole equation\n  // Also having it in an array allows us to pop the values if we want to\n  // clear just one value, making it future proof\n\n  for (let i = 0; i < calcArrayUpdated.length; i++) {\n    // Grab the value;\n    let item = calcArrayUpdated[i]; // Test if the last value is an operator\n\n    let isOperator = /(\\+|-|\\*|\\/)/.test(item); // Sets the last operator in the array\n    // This allows us to make the calculation in the next loop\n\n    if (isOperator) {\n      operator = item;\n    } else {\n      result = operatorFunctions[operator](result, parseInt(item));\n    }\n  }\n\n  return result;\n};\nexport const addValueToCalculation = (value, currentState) => {\n  currentState = [...currentState]; // List of operators to check for \n\n  let operatorValues = ['*', '/', '+', '-']; // If not number or operator then return\n  // this is used in the case of adding to calculation with keypresses\n\n  if (typeof value !== 'number' && !operatorValues.includes(value)) {\n    return currentState;\n  } // If the new value is an operator the calculation array is empty\n  // Then do nothing\n\n\n  if (operatorValues.includes(value) && !currentState.length) {\n    return currentState;\n  } // Todo check if operator was last entry\n  // Get the previous value so we can check it is an operator\n\n\n  let lastVal = currentState[currentState.length - 1]; // Test is last value is an operator\n\n  let lastValIsOperator = operatorValues.includes(lastVal); // Test is current value is an operator\n\n  let currentValIsOperator = operatorValues.includes(value); // Check if last val in array is an operator\n  // Then replace it if new value is an operator\n\n  if (lastValIsOperator && currentValIsOperator) {\n    // Clone the state so we can replace the value\n    // Replace last operator with new operator\n    currentState[currentState.length - 1] = value; // Break out of the function\n\n    return currentState;\n  }\n\n  return [...currentState, value];\n};","map":{"version":3,"sources":["/Users/anikraj/Downloads/engagePulse/calculator-app/src/utils/index.js"],"names":["calculation","calcArray","currentResult","isNaN","length","operatorFunctions","a","b","calcString","join","calcArrayUpdated","split","result","operator","i","item","isOperator","test","parseInt","addValueToCalculation","value","currentState","operatorValues","includes","lastVal","lastValIsOperator","currentValIsOperator"],"mappings":"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","sourcesContent":["export const calculation = (calcArray, currentResult) => {\n  // Get the current calc array \n  // Convert calc array to string\n  // Split string based on operators (/ * - +)\n  // Loop over array and make calculation\n  if (isNaN(calcArray[calcArray.length-1])) {\n    return currentResult;\n  }\n\n  // Operator functions that are invoked\n  // on the loop to calculate the values\n  // in calculation array\n  const operatorFunctions = {\n    '+': (a, b) => {\n        return a + b;\n    },\n    '-': (a, b) => {\n        return a - b;\n    },\n    '*': (a, b) => {\n        return a * b;\n    },\n    '/': (a, b) => {\n        return a / b;\n    }\n  };\n\n  // Join the calc array to create a string\n  // I do thos to make it easier to join the numbers\n  // so that the calculation loop can be done\n  let calcString = calcArray.join('');\n\n  // Split the calc string based on the operators\n  // This will allow me to combine the numbers and seperate\n  // the operators\n  // Example [4,5,'+',2,'/',6] -> '45+2/6' -> ['45','+','2','/','6']\n  let calcArrayUpdated = calcString.split(/(\\+|-|\\*|\\/)/g);\n\n  // Set default result to 0\n  let result = 0;\n\n  // Set a default operator value\n  // I do this as having non assigned vars\n  // is bad practice in most companies I have worked for\n  let operator = '+';\n\n  // Loop and calculate\n  // I do this to ensure that the correct order of operations is achieved\n  // If I did standard math on the values it would follow the\n  // order of operations as if it was a whole equation\n  // Also having it in an array allows us to pop the values if we want to\n  // clear just one value, making it future proof\n  for (let i = 0; i < calcArrayUpdated.length; i++) {\n    // Grab the value;\n    let item = calcArrayUpdated[i];\n    // Test if the last value is an operator\n    let isOperator = /(\\+|-|\\*|\\/)/.test(item);\n\n    // Sets the last operator in the array\n    // This allows us to make the calculation in the next loop\n    if (isOperator) {\n      operator = item;\n    } else {\n      result = operatorFunctions[operator](result, parseInt(item));\n    }\n  }\n  \n  return result;\n}\n\nexport const addValueToCalculation = (value, currentState) => {\n  currentState = [...currentState];\n  \n  // List of operators to check for \n  let operatorValues = ['*', '/', '+', '-'];\n\n  // If not number or operator then return\n  // this is used in the case of adding to calculation with keypresses\n  if (typeof value !== 'number' && !operatorValues.includes(value)) {\n    return currentState;\n  }\n\n  // If the new value is an operator the calculation array is empty\n  // Then do nothing\n  if (operatorValues.includes(value) && !currentState.length) {\n    return currentState;\n  }\n\n  // Todo check if operator was last entry\n  // Get the previous value so we can check it is an operator\n  let lastVal = currentState[currentState.length-1];\n  \n  // Test is last value is an operator\n  let lastValIsOperator = operatorValues.includes(lastVal);\n  \n  // Test is current value is an operator\n  let currentValIsOperator = operatorValues.includes(value);\n  \n  // Check if last val in array is an operator\n  // Then replace it if new value is an operator\n  if(lastValIsOperator && currentValIsOperator){\n    // Clone the state so we can replace the value\n    // Replace last operator with new operator\n    currentState[currentState.length-1] = value;\n    \n    // Break out of the function\n    return currentState;\n  }\n  \n  return [...currentState, value];\n}\n"]},"metadata":{},"sourceType":"module"}